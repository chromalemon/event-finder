FUNCTION register_user(name, email, password, age)
    // Prevent duplicate accounts
    IF EXISTS users WHERE email == email THEN
        DISPLAY "Email already registered"
        STOP
    ENDIF

    // Basic policy checks
    IF age < 13 THEN
        DISPLAY "You must be at least 13 years old"
        STOP
    ENDIF

    IF password TOO_WEAK THEN
        DISPLAY "Password not strong enough"
        STOP
    ENDIF

    // Store password securely
    PASSWORD_HASH = HASH(password)
    INSERT INTO users (name, email, PASSWORD_HASH, age)

    DISPLAY "Registration successful"
    REDIRECT dashboard
ENDFUNCTION

FUNCTION login_user(email, password)
    // Identity lookup
    USER = ONE FROM users WHERE email == email
    IF USER IS NULL THEN
        DISPLAY "Account not found" 
        STOP
    ENDIF

    // Password verification
    IF NOT VERIFY_HASH(password, USER.password_hash) THEN
        DISPLAY "Incorrect password"
        STOP
    ENDIF

    // Session creation
    CREATE_SESSION(USER.user_id)
    DISPLAY "Login successful"
    REDIRECT dashboard
ENDFUNCTION

FUNCTION create_event(host_id, title, description, start_time, end_time,
        capacity, category_ids, location_obj)
    // Basic field and time checks
    IF title  EMPTY OR start_time >= end_time THEN
        DISPLAY "Invalid title or time"
        STOP
    ENDIF

    IF location_obj MISSING THEN
        DISPLAY "Location required"
        STOP
    ENDIF

    // Atomic creation to keep related tables consistent
    BEGIN_TRANSACTION
        EVENT_ID = INSERT INTO events (host_id, title, description, start_time, end_time,
            capacity, location_ref)

        // Link selected categories (M:M)
        FOR EACH cat_id IN category_ids DO 
            INSERT INTO event_categories (event_id = EVENT_ID, cat_id = cat_id)
        ENDFOR

        // Host attends by default
        INSERT INTO event_attendees (user_id = host_id, event_id = EVENT_ID, status = "going") 
    COMMIT_TRANSACTION
    
    DISPLAY "Event created"
    REDIRECT event_details(EVENT_ID)
ENDFUNCTION

FUNCTION update_event(user_id, event_id, new_fields, new_category_ids)
    //Ownership enforcement
    EVENT = ONE FROM events WHERE event_id == event_id
    IF EVENT IS NULL THEN
        DISPLAY "Event not found"
        STOP
    ENDIF

    IF EVENT.host_id != user_id THEN
        DISPLAY "Not authorised to edit"
        STOP
    ENDIF

    // Prevent invalid time edits
    IF new_fields.start_time EXISTS AND new_fields.end_time EXISTS 
        AND new_fields.start_time >= new_fields.end_time THEN
        DISPLAY "Invalid times"
        STOP
    ENDIF

    // Keep event + category links consistent
    BEGIN_TRANSACTION
        UPDATE events SET fields = new_fields WHERE event_id == event_id
        IF new_category_ids PROVIDED THEN
            DELETE FROM event_categories WHERE event_id == event_id
            FOR EACH cat_id IN new_category_ids DO
                INSERT INTO event_categories (event_id, cat_id)
            ENDFOR
        ENDIF
    COMMIT_TRANSACTION

    DISPLAY "Event updated"
ENDFUNCTION

FUNCTION join_event(user_id, event_id)
    // Ensure event exists
    EVENT = ONE FROM events WHERE event_id == event_id
    IF EVENT IS NULL THEN 
        DISPLAY "Event not found"
        STOP
    ENDIF

    // Handle idempotence (user trying to join again) and policy statuses
    ATT = ONE FROM event_attendees WHERE user_id == user_id AND event_id == event_id
    IF ATT EXISTS THEN
        IF ATT.status = "banned" THEN DISPLAY "Access denied; STOP
        IF ATT.status = "going" THEN DISPLAY "Already attendind"; STOP
        IF ATT.status = "waitlist" THEN DISPLAY "Already on waitlist"; STOP
        // not_going falls through as a fresh attempt
    ENDIF
    
    // Reserve a place or waitlist automatically
    BEGIN_TRANSACTION
        GOING_COUNT = COUNT FROM event_attendees WHERE event_id == event_id 
            AND status == "going" FOR UPDATE
        IF EVENT.capacity IS NOT NULL AND GOING_COUNT >= EVENT.capacity THEN
            UPSERT event_attendees SET status = "waitlist" WHERE user_id == user_id
                AND event_id == event_id
            DISPLAY "Added to waitlist"
        ELSE
            UPSERT event_attendees SET status = "going" WHERE user_id == user_id
                AND event_id == event_id
            DISPLAY "Joined event"
        ENDIF
    COMMIT_TRANSACTION
ENDFUNCTION

FUNCTION leave_event(user_id, event_id)
    // Must already have a relationship to leave
    ATT = ONE FROM event_attendees WHERE user_id == user_id AND event_id == event_id
    IF ATT IS NULL OR ATT.status == "not_going" THEN
        DISPLAY "You are not attending"
        STOP
    ENDIF

    // Free place and promote next waitlisted user
    BEGIN_TRANSACTION
        // Mark this user as not going
        UPDATE even_attendees SET status = "not_going" WHERE user_id == user_id 
            AND event_id == event_id
        
        // Promote next waitlisted attendee, if any (earliest join first)
        NEXT = ONE FROM event_attendees WHERE event_id == event_id 
            AND status == "waitlist" ORDER BY joined_at ASC
        IF NEXT EXISTS THEN
            UPDATE event_attendees SET status = "going" WHERE user_id == NEXT.user_id
                AND event_id == event_id
            NOTIFY NEXT.user_id "Moved from waitlist to attending"
        ENDIF
    COMMIT_TRANSACTION
    
    DISPLAY "You have left the event"
ENDFUNCTION

FUNCTION search_events(keyword, category_list, location_text, date_from, date_to)
    // Start from all events, then apply independent filters
    EVENTS = ALL events

    // Text search
    IF keyword PROVIDED THEN
        EVENTS + EVENTS WHERE (title CONTAINS keyword) OR (description CONTAINS keyword)
    ENDIF

    // Category filter via link table (ANY match)
    IF category_list IS NOT EMPTY THEN
        CAT_IDS = IDs FROM categories WHERE name IN category_list
        ALLOWED_EVENT_IDS = DISTINCT event_id FROM event_categories     
            WHERE cat_id IN CAT_IDS
        EVENTS = EVENTS WHERE event_id IN ALLOWED_EVENT_IDS
    ENDIF

    // Location filter (normalised address fields)
    IF location_text PROVIDED THEN 
        EVENTS = EVENTS WHERE (location.city CONTAINS location_text)
            OR (location.country CONTAINS location_text)
    ENDIF

    // Date filter
    IF date_from PROVIDED AND date_to PROVIDED THEN
        EVENTS = EVENTS WHERE start_time >= date_from
            AND end_time <= date_to
    ENDIF
    
    SORT EVENTS BY start_time ASC
    
    // Results and empty state
    IF EVENTS EMPTY THEN
        DISPLAY "No events found"
    ELSE
        DISPLAY EVENTS as list and map pins
    ENDIF
ENDFUNCTION

FUNCTION send_chat_message(user_id, event_id, content)
    // Real-time requires an active connection
    IF NOT websocket_connection_active THEN
        DISPLAY "Connection error"
        STOP
    ENDIF

    // Only hosts/attendees can post
    ROLE = EVENT_ROLE(user_id, event_id) // Host/going/waitlist/NULL/banned
    IF ROLE IS NULL OR ROLE == "banned" THEN
        CLOSE websocket
        DISPLAY "Access denied"
        STOP
    ENDIF

    //Security and policy checks
    CLEAN = REMOVE_UNSAFE_TAGE(content)
    IF LENGTH(CLEAN) = 0 or LENGTH(CLEAN) > 500 THEN
        DISPLAY "Invalid message length"
        STOP
    ENDIF

    // Persist then broadcast to the event group
    INSERT INTO chat_messages (event_id, user_id, content)
    BROADCAST to group "event_chat_{event_id}" the CLEAN message
    DISPLAY "Message sent"
ENDFUNCTION