{% extends "event_finder/base.html" %}

{% block title %}Create Event{% endblock %}
{% block head %}<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>{% endblock %}

{% block content %}
<h1>{% if context == "edit" %}Edit Event{% else %}Create Event{% endif %}</h1>

<form method="POST" enctype="multipart/form-data">
  {% csrf_token %}
  {{ form.non_field_errors }}
  {{ form.errors }}

  {{ form.title.label_tag }} {{ form.title }}<br/>
  {{ form.description.label_tag }} {{ form.description }}<br/>
  {{ form.start_time.label_tag }} {{ form.start_time }}<br/>
  {{ form.end_time.label_tag }} {{ form.end_time }}<br/>
  {{ form.categories.label_tag }} {{ form.categories }}<br/>

  <!-- Hidden location fields (names must match form fields) -->
  <input type="hidden" id="id_formatted_address" name="formatted_address" value="{{ form.initial.formatted_address|default:'' }}">
  <input type="text" id="id_search" name="search" value="{{ form.initial.formatted_address|default:'' }}" placeholder="Location name (search)"/>
  <input type="hidden" id="id_lat" name="lat" value="{{ form.initial.lat|default:'' }}">
  <input type="hidden" id="id_long" name="long" value="{{ form.initial.long|default:'' }}">
  <input type="hidden" id="id_city" name="city" value="{{ form.initial.city|default:'' }}">
  <input type="hidden" id="id_country" name="country" value="{{ form.initial.country|default:'' }}">
  <input type="hidden" id="id_postcode" name="postcode" value="{{ form.initial.postcode|default:'' }}">

  <button type="submit">{% if context == "edit" %}Save Changes{% else %}Create Event{% endif %}</button>
</form>

<div id="map" style="height:400px;"></div>
<!-- Leaflet + your JS should update the hidden inputs -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  const $ = (id) => document.getElementById(id);

  // prefer the real search field id
  const searchInput = $("id_search") || $("id_name");

  const map = L.map("map").setView([51.5074, -0.1278], 13);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "OpenStreetMap",
  }).addTo(map);

  let marker = null;

  function setCoords(lat, lon) {
    if (marker) marker.setLatLng([lat, lon]);
    else marker = L.marker([lat, lon]).addTo(map);

    const latEl = $("id_lat") || $("id_latitude");
    const lonEl = $("id_long") || $("id_longitude");
    if (latEl) latEl.value = Number(lat).toFixed(6);
    if (lonEl) lonEl.value = Number(lon).toFixed(6);
  }

  function setAddressFields(obj) {
    const fmt = $("id_formatted_address");
    const search = $("id_search");
    if (search) search.value = obj.formatted_address || obj.display_name || "";
    if (fmt) fmt.value = obj.formatted_address || obj.display_name || "";

    const cityEl = $("id_city");
    const countryEl = $("id_country");
    const pcEl = $("id_postcode");

    if (cityEl) {
      cityEl.value = obj.city || obj.town || obj.village || obj.hamlet || obj.suburb || "";
    }
    if (countryEl) countryEl.value = obj.country || "";
    if (pcEl) pcEl.value = obj.postcode || "";
  }

  async function reverseGeocode(lat, lon) {
    // use template literal so lat/lon are interpolated correctly
    const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&addressdetails=1`;
    const res = await fetch(url);
    const data = await res.json();
    const address = data.address || {};
    setAddressFields({
      formatted_address: data.display_name,
      display_name: data.display_name,
      city: address.city || address.town || address.village || address.hamlet,
      country: address.country,
      postcode: address.postcode,
    });
  }

  async function forwardGeocode(query) {
    if (!query || !query.trim()) return;
    const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&addressdetails=1&q=${encodeURIComponent(query.trim())}`;
    const res = await fetch(url);
    const data = await res.json();
    if (Array.isArray(data) && data.length) {
      const lat = parseFloat(data[0].lat);
      const lon = parseFloat(data[0].lon);
      map.setView([lat, lon], 15);
      setCoords(lat, lon);

      setAddressFields({
        formatted_address: data[0].display_name,
        display_name: data[0].display_name,
      });

      // optionally populate more precise address via reverse lookup
      reverseGeocode(lat, lon).catch(() => {});
    }
  }

  map.on("click", (e) => {
    const { lat, lng } = e.latlng;
    setCoords(lat, lng);
    if (searchInput) searchInput.value = "Loading address...";
    // do not clear the input after success â€” setAddressFields will populate it
    reverseGeocode(lat, lng)
      .catch(() => { if (searchInput) searchInput.value = ""; });
  });

  if (searchInput) {
    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        forwardGeocode(searchInput.value);
      }
    });

    let t;
    searchInput.addEventListener("input", () => {
      clearTimeout(t);
      t = setTimeout(() =>
        forwardGeocode(searchInput.value), 800);
    });
  }
</script>
{% endblock %}